Cyclic Sequence Generators as Program Counters for High-Speed FPGA-based Processors
P. A. Suggate, R. W. Ward, Dr T. C. A. Molteno
Department of Physics, University of Otago, P.O. Box 56, Dunedin, New Zealand

Abstract This paper compares the performance of conventional radix-2 program counters with program counters based on Feedback Shift Registers (FSRs), a class of cyclic sequence generator. FSR counters have constant time scaling with bitwidth, N , whereas FPGA-based radix-2 counters typically have O(N ) time-complexity due to the carry-chain. Program counter performance is measured by synthesis of standalone counter circuits, as well as synthesis of three FPGA-based processor designs modiﬁed to incorporate FSR program counters. Hybrid counters, combining both an FSR and a radix-2 counter, are presented as a solution to the potential cache-coherency issues of FSR program counters. Results show that high-speed processor designs beneﬁt more from FSR program counters, allowing both greater operating frequency and the use of fewer logic resources. Key words: FPGA-Processor, FSR, LFSR, Feedback Shift Register, Cyclic Sequence Generator, Program Counter 1. Introduction A Program Counter (PC) circuit [10] generates the address of the next instruction to be fetched for execution. The greatest contributor to total PC circuit latency in an FPGA-based processor can be due to the counter that is used to increment the current PC value. This is because conventional radix-2 counters implemented within FPGAs can have long carry chains. Pipelining can be used to obtain a higher operating frequency but also increases logic usage, and likely increases the branch penalty. Non-radix-2 cyclic sequence generators can be used to generate the next instruction address, for example a maximum-cycle Feedback Shift Register (FSR) [5, 13, 6], and can lead to a reduction in total PC latency. This is because FSR counters can be designed where the maximum depth of combinatorial logic required is only one gate [7] therefore the PC latency is constant with bit-width N . We explore how this reduction in PC circuit complexity can aﬀect maximum processor operating frequency for three FPGA processor designs. The sequence of instruction addresses generated by a PC circuit using a maximum-cycle FSR is pseudo-random. For a processor fetching instructions from a small embedded memory this presents no problem. For processors that feature an instruction cache an FSR PC will have poor cache-coherency behaviour. As as solution we present a hybrid PC architecture. The hybid-PC is the concatenation of two smaller counters. The hybrid PC uses a
Email address: tim@physics.otago.ac.nz (Dr T. C. A. Molteno) Preprint submitted to Reconﬁgurable Computing August 12, 2009

small radix-2 counter to step through instructions within a cache line, and a FSR counter that cycles between cache line. When implemented within FPGA processors, this hybrid approach has low latency and avoids cache-coherency problems. 1.1. Program Counters Stan et al. [14] list the properties of generic up/downcounters but not all of these properties are necessary for PC circuits. A program counter must be RESETable, increment once every clock cycle as long as an ENABLE line is asserted, and sometimes has its value changed by branch instructions (so it needs to be LOADable, and have IN lines). The value also needs to be readable every clock cycle (using the OUT lines) in order to access the memory address to fetch the next instruction. There is no need to support other common counter features [14], such as being reversible, or any terminal count operations. A black box diagram for a generic PC circuit is shown in Figure 1.

N

IN LOAD ENABLE RESET CLK

OUT

N

Figure 1: Black box program counter model showing the required control signals. The LOAD, ENABLE, and RESET actions all occur on the positive edge of the clock (CLK).

1.2. Radix-2 Counters Synchronous radix-2 counters are conventionally used for Program Counters, however there is a trade-oﬀ between speed and size because of carry propagation from low-order to higher-order bits [14]. The simplest radix-2 counter is a ripple-carry counter based on an adder [14]. This is slow (O(N ) combinatorial delay with increasing bit-width N ) but cheap in logic (O(N )). Xilinx FPGAs use carry chains to provide the logic for this. This can be improved to O(log N ) combinatorial delay using a carry-lookahead design [9] at the expense of extra logic. An approach that allows increment in constant time is a redundant format [8] which allows what is called ‘carryfree’ addition, but that has two issues. A redundant representation needs twice as many latches and therefore consumes more FPGA resources. Another problem is that a redundant output is unsuitable for providing an address to access instructions. The output ﬁrst needs to be converted to a non-redundant format during each clock cycle, which is going to require O(log N ) propagation delay and extra logic for an adder. Some work has been done using hybrid redundant number systems [11] to reduce the number of extra registers, but there is still a substantial propagation delay converting that to a usable format. Another approach to designing an O(1) delay counter is to use a cascade [9] that begins with a short and fast counter, and continues with longer counters that only need to be incremented occasionally and don’t need to be as fast. However, this requires the slower counters to have their increments to be precomputed [14] which makes the LOAD operation much more diﬃcult. 1.3. Cyclic Sequence Generators A cyclic sequence generator is a synchronous circuit that iterates through a cyclic sequence of states. For a program counter, it is desirable to have a simple circuit and a cyclic sequence that includes most of the possible states. A good candidate for this is a maximum cycle feedback shift register. A Feedback Shift Register (FSR) is a shift register that satisﬁes the condition that the current state is generated by a linear function of its previous state. There are many types of these, but the ones considered here are linear (use XOR gates), and have a constant maximum combinatorial path, therefore constant time performance (O(1)) with increasing bit width N (see Figure 2 for some examples of these). This compares favourably with radix-2 counters as described in Section 1.2. A well-known example of an FSR is a Linear Feedback Shift Register [5, 6] (LFSR) that are widely used in cryptography [6], communications systems [12] and for built-in self-test systems [1]. A few of the types of FSR are: Fibonacci LFSR takes the output of several of the registers and XORs them together to feed to the input of the ﬁrst register as shown in Figure 2a. 2

(a) (b) (c) (d)
Figure 2: 8 bit counters with a cycle size of 255. (a) Fibonacci LFSR, (b) Galois LFSR, (c) Ring Generator, (d) MFSR

Galois LFSR takes the output of the last register and XORs it with several of the register inputs as shown in Figure 2b. Ring Generators [7] rearrange the shift register into a ring, and arranges the feedback connections so that they only involve a small amount of routing, as shown in Figure 2c. MFSR [18] (Multiple Feedback Shift Register) are a generalisation of ring generators, allowing any output to be XORed with any input, but limits the fan-in and fan-out to 2, as shown in Figure 2d. Also worth considering are cellular automata [3]. These are not Feedback Shift Registers but have similar properties. A cellular automaton has each bit set from the XOR of the previous value of that bit and neighbouring bits, which require more XOR gates than FSRs but keeps the routing very local. An N -stage linear FSR is maximum-cycle when all 2N−1 non-zero states occur as the FSR is iterated. Note that a cycle of 2N cannot be achieved as the all zero state will always map to the all zero state. Any linear FSR can be represented as an N × N matrix M over the ﬁeld GF (2), and this will be maximum cycle if and only of the characteristic polynomial p(x) = |M − xI| is primitive. Lists of primitive characteristic polynomials and counters with maximum cycles can easily be found [6, 2, 17] or generated. All these structures are very fast, as described above, and have a relatively small amount of logic (O(N ) which will mostly be the registers to store the bits), and a pseudorandom sequence. They will have similar performance, due to all having a maximum combinatorial part of just one XOR gate (In Fibonacci this may be 4 gates, but this is still only one LUT on an FPGA). Slight variations in performance may depend on required LUTs and routing in any particular FPGA technology choice and application. The worst case number of XOR gates, fan in and fan out is shown in Table 1. As the sequence is pseudo-random, the bits may also reordered to search for small routing improvements.

Latency (ns)

Structure Fibonacci LFSR Galois LFSR Ring Generator MFSR Cellular Automata

XOR gates 1 3 3 2 N

Fan-in 4 2 2 2 3

Fan-out 2 4 2 2 3

5 4 3 2 1 0 5

Counter Latency vs. Size

Table 1: Worst case XOR gate count, Fan-in and Fan-out for several types of Feedback Shift Register with N bits

FSR counters meet the counter requirements for PC circuit described in Section 1.1. They are easily loadable, support an enable, and the register can be read directly. One disadvantage to using FSRs is that the maximal cycle size is 2n − 1, instead of the 2n cycle of radix-2 counters. We refer to the address not generated in the 2n −1 cycle as the “zero address”. While the zero address does not represent a signiﬁcant fraction of the address space, this can be addressed with extra logic as used by Wang and McCluskey [16], but this brings the propagation delay back to O(log N ). For the rest of this work we use MFSR counters. They have good fan-in, fan-out, and a low gate count. Other FSRs could be used and would have very similar results (see Figure 2). 1.4. Hybrid PCs The instruction fetch order of FSR PCs may lead to poor run-time performance for processor designs that contain an instruction cache. It is desirable to have a PC that increments through all of the instructions within a cache line before fetching a new cache line. For a cache linesize of 32 bytes, and a ﬁxed instruction-width of 32 bits, there will be eight instructions within a cache line. Ideally, and in the absence of branching instructions, each of these eight instructions should be fetched from the cache before fetching another cache line from system memory. The solution presented here is to combine two counters into one PC, a radix-2 counter for the three leastsigniﬁcant bits and a MFSR for the most-signiﬁcant bits. Since the Spartan-3 contains four-input Look-Up Tables (LUTs), and the Virtex-5 has six input LUTs, a 3-bit radix-2 counter can be built with just one layer of logic. When the upper count value is reached, the MFSR portion of the PC is then incremented. 2. FPGA Synthesis of Simple Counter Circuits Performance of the synthesised radix-2 and FSR counters are shown in Figure 3. As the bit-width N increases radix-2 counters show a linear increase in latency, this is O(N ) time-complexity. The results show that for radix2 counters of more than 6 bits, latency can be estimated as 2.9 + 0.064 × N ns. The FSR counters have O(1) time complexity and a smaller constant of only 1.8 ns, compared with the radix-2 counters. 3

Radix-2 FSR 10 15 20 25 Counter Size (bits) 30 35

Figure 3: Counter circuit performance vs. counter size when synthesised for a Spartan-3 FPGA. The radix-2 counter implementation used was the default generated by the Xilinx ISE 9.2 tools. This implementation uses the hardware carry-chain present in Spartan-3 devices.

3. FPGA Synthesis of Complete PC Circuits A simple PC circuit was used when investigating the eﬀect of counter-type on PC performance. Figure 4 is a block diagram of the circuit used for testing and the counter used was one of FSR, radix-2, or a hybrid where the lowest 3 bits are radix-2. Bit widths ranging from 8 to 32 bits were used.

Figure 4: Block diagram of the PC circuit used for the counter comparison tests. The counter type was either a FSR, radix-2, or a FSR-radix-2 hybrid.

3.1. PC Circuit Results The results of the PC circuit synthesis are shown in Figure 5. As with the previous counter tests, the radix2 circuits scale linearly with increasing bit-width. Again though, the latencies of FSR-based circuits are lower than

radix-2 and both the FSR and hybrid PCs have O(1) scaling with increasing bit-width. Due to the Xilinx synthesiser using the carry-chain logic for the radix-2 counters, and FSRs having a gate depth of just one, this is as expected. To demonstrate that the behaviour observed when synthesising for a Spartan-3 FPGA is not unique, Figure 6 also shows synthesis results for a Xilinx Virtex-5 FPGA. The latency scaling with increasing bit-width is similar but the Virtex-5 is clearly a faster architecture.

4. Processor Design Examples Three FPGA processors were synthesised and evaluated to show the eﬀects of diﬀerent PC circuits on maximum clock frequency. The three processor logic cores used are aeMB, TTA16, and RISC16. aeMB was designed to use a conventional radix-2 PC whereas RISC16 and TTA16 were designed to use a PC circuit based on either a FSR or radix-2 counter. This is to examine if substituting a FSR-based PC into an existing processor design leads to any performance gains of the processor as a whole, and if there is a detrimental eﬀect of adding a radix-2-based PC to a processor designed for a FSR-based PC. A Xilinx Spartan-3 FPGA was again the synthesis target and Xilinx ISE 9.2 was the synthesis tool. 4.1. aeMB: A MicroBlaze Compatible RISC Processor The aeMB processor logic core is 32-bit, harvardarchitecture, RISC processor with a three-stage pipeline. It is an open source project that was designed to be instruction compatible with the MicroBlaze core [19]. The aeMB processor core, when synthesised for a Spartan-3 FPGA, uses about 2600 logic elements. The critical path of aeMB, as determined from the Xilinx place-and-route timing report, is the instruction-cache lookup path. Total routing resources used were 515643 paths with the original radix-2 PC. The source code was modiﬁed, substituting a FSR PC for the radix-2 PC, and resynthesised. This was a straight PC-logic substitution and did not address any potential problems with relative branching and cache coherency. Maximum operating frequency increased slightly, as shown in Table 2, logic resource utilisation was similar, but the FSR degign used only 503608 paths. This is a large change in pathing resources used for a small change to the total design. This large diﬀerence in pathing resources, from just a change to the PC circuit, was not observed with the other processor cores. CPU (Name) TTA16 RISC16 aeMB PC Size (Bits) 10 10 30 FSR (MHz) 192 143 84 Radix-2 (MHz) 157 141 80 Pipeline Stages 3 5 3

Program Counter Latency vs. Size - Spartan-3 6 5 Latency (ns) 4 3 2 1 0 5 Radix-2 FSR Hybrid 10 15 20 25 30 Program Counter Size (bits) 35

Figure 5: Xilinx Spartan-3 FPGA synthesis results of PC circuit performance vs. counter size. PCs with three counter types are compared: FSR, radix-2, and a FSR-radix-2 hybrid (Lower 3 bits radix-2, upper bits FSR).

Program Counter Latency vs. Size - Virtex-5 2.0

Latency (ns)

1.5

1.0 Radix-2 0.5 FSR Hybrid 10 15 20 25 30 Program Counter Size (bits) 35

0.0 5

Table 2: Three diﬀerent processor designs were synthesised, each with a FSR PC and with a radix-2 PC. Gains are negligible except when the PC circuit is the critical path, as with TTA16.

Figure 6: Xilinx Virtex-5 FPGA synthesis results show that these devices are faster than Spartan-3 FPGAs. The latency is lower but the comparative diﬀerences between counter types is still very similar. The Virtex-5 FPGA is from the Xilinx performance range of FPGAs. The Virtex-5 was used to demonstrate that the Spartan-3 results can apply to other FPGAs.

4.2. TTA16 TTA16 is a 16-bit, Transport Triggered Architecture [4] (TTA) processor optimised for Xilinx Spartan-3 FPGAs. It is an open source, harvard architecture processor and was designed for the high-throughput, data-processing tasks of the Open Video Graphics Adapter (OpenVGA) 4

project [15]. TTA processors have very simple instruction word formats and require only very simple instruction decoders resulting in smaller processor cores. The TTA16 PC circuit is similar to that shown in Figure 4 and contains source code for both types of PC, FSR or radix-2, and can be synthesised with either one. TTA16 was the processor that showed the greatest frequency improvement with an FSR PC (see Table 2), the FSR counter has 22% greater clock frequency than with the radix-2 counter. TTA16 conﬁgured to use the FSR PC is substantially faster than with the radix-2 PC because TTA16 was designed to use a low-latency PC circuit. When TTA16 is synthesised with a radix-2 counter the PC circuit becomes the critical path limiting maximum frequency. We speculate that adding an additional pipeline stage to the radix-2 PC circuit may improve maximum processor frequency, but this would also increase branch latency and FPGA resources required. 4.3. RISC16: A Small 16-bit RISC Processor RISC16 was also designed for OpenVGA [15], for comparison with TTA16, and shares many design elements. The RISC16 core is has ﬁve pipeline stages, arranged such that each has similar latency, so decreasing the latency of one small component, the PC circuit, would not be expected to have a big eﬀect on overall performance. Table 2 shows that there was no substantial diﬀerence between the FSR and radix-2 PC implementations of the RISC16 processor core. 5. Discussion Radix-2 counters are the conventional counters used for the processors PC. These have been studied and used extensively. Memories, including caches, often support linear, burst transfers assuming a radix-2 count order. Current software tools, like assemblers and compilers, assume a radix-2 count order as well. FPGAs, like the Xilinx Spartan-3 and Virtex-5 families, contain carry chains to support radix-2 counters as well. Traditional assemblers will generate object code suitable only for the radix-2 PC increment sequence. For processors with FSR-based PCs, an assembler is needed that will use a description of the FSR to correctly re-order the processor instruction. An assembler was developed for this purpose and reads an XML-encoded complete processor description prior to generating the assembly output. The assembler supports FSR, radix-2, and hybrid PCs that support concatenation of an arbitrary number of FSR and radix2 counters. For each FSR counter used the tap sequence describing the FSR is also encoded within the processor description ﬁle. 5.1. FSR Program Counters The FSR counters are very fast (see Figure 4) leading to a substantially lower-latency PC circuit (see Figure 3). 5

This in turn leads to notable gains in maximum processor operating frequency for the processor with the highest operating frequency, TTA16 (see Table 2). Because a maximal-cycle FSR count cycle is diﬀerent from a radix-2 counter this has eﬀects on tools, instruction encoding, and cache coherency. 5.1.1. Relative Instruction Addressing PC-relative branching, branching to the address calculated by adding a value to the current PC, is hard to do with FSRs. With radix-2 PCs, a value, usually with a lower bit-width, can be added to the current PC value to calculate the branch destination address. This approach allows a subset of addresses, those that are close to the current instruction, can be encoded within an instruction using fewer bits. The simplest approach is to not support PC relative branching with FSR based PCs. This could make instruction encoding for PCs with a large number of bits diﬃcult. 5.1.2. Cache Coherency For processor designs featuring an instruction cache, a FSR-based PC will lead to poor performance. A single FSR-based PC circuit will traverse program memory in a pseudo-random count cycle. Caches are typically designed to fetch multiple words from sequential adresses, called cache lines. A FSR PC circuit may only execute one instruction from this cache line, and then the cache may need to fetch another. A solution to this problem is introduced in Section 1.4 and then issues are discussed in Section 5.2. 5.2. Hybrid Program Counters The synthesis results, shown in Figures 5 and 6, for the hybrid PCs described in Section 1.4 show that performance is greater than radix-2 PCs at all tested bit-widths. They are therefore a good solution to the cache coherency problems of FSRs. Figures 5 and 6 show that hybrid PCs have only slightly higher latency than pure FSR PCs and with the same constant-latency behaviour with increasing N . Hybrid PCs can also be used to solve problems with relative branching and position independent code, though this is future work. With a hybrid-PC, the FSR portion will not increment when its value is zero, so there is one entire cache line which will not be accessed by the count cycle. This need not be a disadvantage because the ﬁrst cache line could be used to store other information, for example the interrupt vector table. 6. Conclusions We have designed PC circuits that can allow some FPGA-based processors to operate at higher frequencies. This is because FSR-based counters have very low latency, a depth of just one logic gate, and PC circuits utilising

FSRs can have substantially lower latency when implemented in FPGAs. Due to the constant-time behaviour, with increasing bit-width N , FSR counters have an even greater advantage, relative to radix-2 counters, when N is large. For small embedded FPGA processors executing instructions stored in local SRAMs, the pseudo-random count cycle of FSRs is no signiﬁcant problem either as long as the user has the necessary tools to generate code. We have also presented hybrid PCs to solve the FSR cachecoherency issues for processors that use an instruction cache to reduce average latency for instruction fetching. 6.1. Future Work There can be many possible maximal-cycle FSRs for a given bit-width. Some FSRs, due to each having a slightly diﬀerent circuit, may be faster for a particular implementation than others. Testing was not performed to ﬁnd the fastest available FSR circuit for a particular implementation. A future project might be searching amongst the many possible FSRs to ﬁnd the lowest latency circuit. Modern compilers can generate position independent code making use of relative branching that is not practicable with a pure FSR-based PC. Further work exploring hybrid program counters, consisting of three or more smaller counters, could probably be used to solve the FSR relative addressing problems. The emphasis of this work is on FPGA-based processors. Due to their very low gate depth and reduced logic complexity FSR and FSR-radix-2 hybrid PCs may also prove useful with some vey low gate-count, or very high clock frequency processors realised in Silicon. References
[1] V.D. Agrawal, C.R. Kime, and K.K. Saluja. A Tutorial on Built-in Self-Test. I. Principles. IEEE Design & Test, 10(1):73– 82, 1993. [2] Peter Alfke. Application Note: Eﬃcient Shift Registers, LFSR Counters, and Long Pseudo- Random Sequence Generators. Technical report, Xilinx Inc., San Jose, CA, 1996. App. note XApp052. [3] T. Chang, I. Song, J. Bae, and K.S. Kim. Maximum length cellular automaton sequences and its application. Signal Processing, 56(2):199–203, 1997. [4] H. Corporaal. Transport triggered architectures examined for general purpose applications. In Sixth Workshop on Computer Systems, pages 55–71, 1994. [5] S.W Golomb. Shift Register Sequences. Aegean Park Press, Laguna Hills, CA, USA, 1981. [6] A. Menezes, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC Press, Boca Raton, 1997. [7] G. Mrugalski, N. Mukherjee, J. Rajski, and J. Tyszer. High Performance Dense Ring Generators. IEEE Transactions on Computers, pages 83–87, 2006. [8] B. Parhami. Systolic up/down counters with zero and sign detection. In Proc. Symp. Comput. Arithmetic, pages 174–178. [9] B. Parhami. Computer arithmetic. Oxford University Press, 2000. [10] B. Parhami. Computer Architecture: From Microprocessors to Supercomputers (Oxford Series in Electrical and Computer Engineering). Oxford University Press, Inc. New York, NY, USA, 2005.

[11] DS Phatak and I. Koren. Hybrid signed-digit number systems: a uniﬁed framework forredundant number representations with bounded carry propagation chains. IEEE Transactions on computers, 43(8):880–891, 1994. [12] R. Pickholtz, D. Schilling, and L. Milstein. Theory of Spread-Spectrum Communications–A Tutorial. Communications, IEEE Transactions on [legacy, pre-1988], 30(5 Part 2):855–884, 1982. [13] M.J.B. Robshaw. Stream Ciphers. RSA Labratories, 25, 1995. [14] M.R. Stan, A.F. Tenca, and M.D. Ercegovac. Long and Fast Up/Down Counters. IEEE Transactions on Computers, 47(7):722– 735, 1998. [15] P. Suggate. OpenVGA: An Open-Source PCI Graphics Adapter. Master’s thesis, University of Otago, 2009. [16] L.T. Wang and E.J. McCluskey. Hybrid designs generating maximum-length sequences. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on, 7(1):91– 99, 1988. [17] R. W. Ward and T.C.A. Molteno. Table of multiple feedback shift registers. Technical Report 2009-1, University of Otago, 2009. [18] Roy W. Ward and T.C.A. Molteno. Counter Representations in Microprocessors. In ENZCon06 Conference Precedings. ENZCon, 2006. [19] Xilinx Inc. Microblaze processor reference guide, 2008.

6

