\chapter{Summary, Conclusions, and Future Work}
\label{CONCLUSION}

Concluding this thesis is a summary of OpenVGA, the useful logic cores that were
developed, how these cores compared to those of other projects, and possibilities
for future work following on from this project. Future work, even if completed by
others, can be directly contributed back to the OpenVGA project. This is because
OpenVGA is an open-source project and licensed under the GPL.


\section{Summary of the OpenVGA Project}

OpenVGA development has reached the point where it can function as a secondary
graphics adapter. The OpenVGA local memory, an 8 MB SDRAM IC, is mapped into the
host system's address space, and its contents are accessible via the PCI Local
Bus. The contents of a portion of this memory, the framebuffer, can be displayed
on a VGA monitor, either a CRT or LCD display, that is connected to OpenVGA.

The design of OpenVGA is also very modular, and many of its components
interconnect using standard protocols. This applies to both the connections to
and from the PCB, connections between components on the PCB, and connections
between the logic cores within the Spartan-3 FPGA.

OpenVGA also contains a processor, implemented within the FPGA, with associated
firmware for initialisation tasks. Additional functionality can easily be added
by writing additional firmware. Firmware can be included during synthesis, stored
in the on-board serial PROM, or uploaded through the PCI Local Bus. OpenVGA was
designed so that this on-board processor can be used to emulate a subset of VGA
functionality. This would allow it to function as a primary graphics adapter once
complete, but this is future work.

A Linux kernel module has been developed that allows software to access OpenVGA's
local memory. Data can be written to, and read from, OpenVGA using this kernel
module. Any data written to the framebuffer region of memory will be displayed on
a VGA monitor connected to OpenVGA.

Software has been produced for this project too. There are utilities for
converting data between the different formats required, such as the tool to
convert the files generated by the assembler into a format that can be included
within the processor's Verilog source code. Other tools developed are an
assembler for RISC16, a CRT simulator for developing the display-controller logic
core, and a cache simulator that was used to analyse and select cache design
parameters, and code to simulate text-mode.

The text-mode simulator was written to provide a realistic workload for the
processor when choosing cache parameters. This piece of code would be a good
starting point for developing firmware to support VGA's alphanumeric
display-modes.


\section{OpenVGA Logic Cores}
The complete set of OpenVGA digital logic circuits requires only a small quantity
of logic and it can be embedded into larger SoC projects with little penalty. The
complete design uses less than 1100 slices of the Spartan-3 FPGA that it was
synthesised for. The Spartan-3 used does not contain a lot of programmable logic
compared to many other FPGAs, it is the second smallest device within the
Spartan-3 product range~\cite{Xilinx_SP3_DS}. OpenVGA used only 60\% of the
available FPGA logic. According to Xilinx, the XC3S200 is supposed to contain the
equivalent of about 200,000 logic gates, and modern ASICs can contain hundreds of
millions of logic gates.


\subsection{Summary of Important OpenVGA Logic Cores}
Many of the logic cores that have been developed for OpenVGA have been heavily
tested and optimised. All of the logic cores are written in the industry standard
Verilog HDL. Except for the asynchronous FIFOs, the external interfaces of these
logic cores are compatible with the Wishbone interconnect standard. These factors
mean that many of the following logic cores will likely be of use to other
projects.

The logic cores presented in Table~\ref{SUMMARY_Cores} are the sizes and speeds
of the cores when synthesised alone, with high optimisation settings, optimised
for speed, not area, and with parameters set to the configuration used within
OpenVGA. Theses numbers are approximate and depend a lot on many other factors.
Speeds will be lower when included in large designs, unless manually
floor-planned. And changing the optimiser setting to area, not speed, should
result in lower resource usage in more resource-limited designs.

\begin{table}[h!]
\begin{center}
\begin{tabular}{l | c c l}
Logic Core				& Speed	& Size	& Other logic elements used	\\
						& (MHz)	& (LEs)	&	\\
\hline
TTA16					& 190	& 200	& 2 BRAMs, 1 multiplier	\\
RISC16					& 140	& 320	& 1 BRAM, 1 multiplier	\\
Data Cache				& 150	& 80	& 1 BRAM	\\
PCI to Wishbone Bridge	& 110	& 320	&	\\
SDRAM Controller		& 120	& 100	&	\\
Display Controller		& 140	& 200	&	\\
Async. FIFO, 32-bit, 16-entry	& \texttt{>}150	& 60	&	\\
\end{tabular}
\caption[Summary of significant OpenVGA logic cores]{Summary of significant
OpenVGA logic cores.}
\label{SUMMARY_Cores}
\end{center}
\end{table}


\subsubsection{TTA16: A 16-bit TTA Processor}
A TTA processor logic core with a 32-bit instruction width, 16-bit data width,
4~kB of local instruction SRAM, three pipeline stages, and four data transports
was developed for OpenVGA. When synthesised for the Spartan-3, operating
frequency was up to 150~MHz, and using about 200 logic slices.

Unusual amongst processors, TTA16 does not support exceptions due to the extra
complexity this would have added to the design. This processor also features
interleaved instructions and no data-hazard interlocks, so it is difficult to
write assembly code for (see the programming guide in
Appendix~\ref{TTA_Programming}). The result is a processor that compares
favourably with other FPGA-based processors (see Table~\ref{SUMMARY_CPU_Table}).


\subsubsection{RISC16: A 16-bit RISC Processor}
This is a RISC processor with a 16-bit instruction width, 16-bit data width, 2 kB
of local instruction SRAM, five pipeline stages, and data forwarding. It was
developed for OpenVGA because TTA16 was such a difficult processor to write code
for and the result is a processor that is far easier to program (a programming
guide for RISC16 has been included as Appendix~\ref{RISCPROG}). Consequently, it
shares many of the same functional units and design techniques as TTA16, and
therefore has value for comparison with TTA16.

This logic core has the same external interfaces as TTA16 and these logic cores
be used interchangeably within a design, as long as the correct code is provided
for each processor as the instruction sets differ. Compared to TTA16, RISC16
operates at a lower frequency \texttt{>}100 MHz, but not higher than 140 MHz, and
uses more logic slices, 320 compared to 200, than TTA16, but is easier to
program. Creating a compiler would be easier as well, though beyond the scope of
this work.


\subsubsection{Data Cache}
The data cache can operate at more than 150 MHz and uses about 80 logic slices
when synthesised for a Spartan-3 FPGA (see Table~\ref{SUMMARY_Cores}). The data
cache significantly improved average memory latency with the text-mode conversion
algorithm, from 47 down to 5 clock cycles. This cache is 2 kB in size, a line
size of 64 bytes, and is a 2-way set-associative design. The cache sense logic
features a fast-hit path, with a latency of zero clock cycles, which is used when
calculating a hit within the same cache-line as the previous request. And a
slower-hit path, with a latency of one cycle, if the request is for a different
cache line.

An additional feature is that this cache is a dual synchronous-clock design. It
has two Wishbone interfaces, one that is connected to a processor and supports a
data width of 16-bits. The other Wishbone interface is to be connected to the
memory bus, which has a data width of 32-bits. The processor's Wishbone interface
can be driven at a frequency which is an integer multiple of the memory bus clock
frequency, as long as the two clock signals are synchronous, and both satisfy
their required timing constraints.


\subsubsection{Parameterisable SDRAM Memory Controller}
This memory controller design is simple, fast, and supports burst data transfers.
The maximum frequency at which the controller could operate, error free, was 120
MHz, which is 240 MB/s with a memory IC that has a 16-bit data bus, on a two
layer PCB with a Spartan-3.

The bit widths of the address, internal, and external data buses are
parameterisable. This memory controller can therefore be configured for many
applications. The configuration used within OpenVGA was a 32-bit internal data
bus width, an external 16-bit data bus width, and a 21-bit address width (the
size and speed for this configuration are shown in Table~\ref{SUMMARY_Cores}).

As an example, the controller could be parameterised to support an external bus
of 32-bits. This could be a design which used two 16-bit SDRAMs, or four 8-bit
SDRAMs. An external data width of 32-bits would require that the internal
Wishbone interconnect be 64-bits wide, since the external data bus operates at
twice the frequency of the internal bus.


\subsubsection{PCI-to-Wishbone Bridge}
The PCI-to-Wishbone bridge allows data to be transferred between clock domains
and bus protocols. The PCI Local Bus is a standard for transferring data between
components on system boards within a PC. The Wishbone interconnect is intended
for data transfer between logic cores within a single IC. This bridge features
asynchronous FIFOs so that PCI and Wishbone can operate within separate clock
domains. A FIFO is needed for each data-transfer direction, so two were used.

Even though the original PCI Local Bus specification is now considered obsolete,
and succeeded by PCI Express~\cite{budruk2003pes}, PCI is still popular and has a
considerable installed base. The PCI Local Bus is still found in many computers,
even those currently being produced. Due to the size of the installed base, there
are still reasons to use it, and therefore this logic core, in new designs.


\subsubsection{Video Controller}
This is a logic core that generates a data stream and the timing signals for
driving VGA and DVI monitors (though DVI is untested and this is future work).
This Wishbone-compatible core is sufficiently general-purpose and flexible to be
useful for any application which connects to a VGA or DVI display. The core
features a 2 kB prefetch queue, implemented using an asynchronous FIFO, so the
dot-clock and Wishbone clock can be in separate clock domains. The data prefetch
also makes the display redraw less susceptible to memory bus congestion.


\subsubsection{Asynchronous FIFOs}
Two asynchronous FIFOs were developed, one with 16 entries, and the other with a
capacity of 2048 bytes. These FIFOs are optimised for the Spartan-3 architecture,
to take advantage the of the Spartan-3 RAM primitives for efficient
implementation. The width of the data bus is parameterisable for the 16-entry
FIFO. A width of 32-bits is used for the PCI-to-Wishbone bridge, and
Table~\ref{SUMMARY_Cores} lists the speed and size in this configuration.

Asynchronous FIFOs are important when multiple bit-width data needs to be
transferred across clock domains. The design of these FIFOs ensures that
metastability problems are avoided~\cite{Async_FIFO2}.


\subsection{Processor Comparison and Summary}
\label{SUMMARY_CPU}
Two processors were developed for OpenVGA, a traditional RISC design, RISC16,
and a processor with a novel transport-triggered architecture, TTA16 . Relative
to RISC16, the TTA16 processor uses fewer logic resources, operates at higher clock
frequencies, and can perform more operations per clock cycle (see
Section~\ref{TTA16}).

RISC16 has a 16-bit instruction word, instead of the 32-bit wide instructions of
TTA16, leading to far better code density. It is also a simpler architecture to
program in assembly language, data-forwarding and interlocking help here, and
RISC16 is similar to processors with GCC ports. But due to the added complexity
of RISC16 it is both larger and slower than TTA16 .


\begin{table}[h!]
\begin{center}
\begin{tabular}{l | r r c c l}
CPU Name & Speed & \multicolumn{1}{c}{Size} & Compiler & Open- &
Notes \\

	& \multicolumn{1}{c}{(MHz)}	& \multicolumn{1}{c}{(Slices)} & & Source & \\
\hline

MicroBlaze~\cite{xilinx2008mpr} & 115 & \~1000 & Yes & No & Proprietary \\

PicoBlaze~\cite{xilinx2008ppr} & 90 & 90 & No & Yes & Limited address space \\

ZPU~\cite{ZPU} & 90 & \~400 & GCC & Yes &	\\

OR1k~\cite{OpenRISC} & 30 & 2000 & GCC & Yes &	\\

GR0040~\cite{FPGACPU} & 30 & 200 & LCC & Yes & Restrictive license \\

RISC16 & 140 & 320 & No & Yes & Lcc port possible	\\

TTA16 & 190 & 200 & No & Yes & \begin{minipage}{0.3\linewidth} Fast but
difficult to program and poor code density. \end{minipage} \\

\end{tabular}
\caption[Evalualted processors and a comparison with TTA16 and
RISC16]{Evaluated processors and a comparison with TTA16 and RISC16.}
\label{SUMMARY_CPU_Table}
\end{center}
\end{table}

A summary of the processors that were compared with TTA16 and RISC16 are listed
in Table~\ref{SUMMARY_CPU_Table}. All of the operating speeds and numbers of
logic slices used are approximate and depend heavily on the parameters used,
optimisation settings, and the other components within a design. This table just
indicates what can be expected in best-case scenarios.

In terms of size and performance, both of OpenVGA's processor logic cores compare
favourably to other FPGA-based processors, as Table~\ref{SUMMARY_CPU_Table}
shows. TTA16 is the standout here in terms of performance, and RISC16 is fast as
well. All processors listed have assemblers, but TTA16 and RISC16 lack C
compilers. ZPU, MicroBlaze, and OR1k are all 32-bit processors, so based on this
table, ZPU is clearly the best of these. It would have been a good candidate for
OpenVGA, but unfortunately this processor only recently reached a usable
state~\cite{ZPU}.


\subsection{Known Bugs}
There exists a known bug within the SDRAM controller logic core and this is
covered in Section~\ref{SDRAM_Bug}. Fortunately, this is the only known bug with
OpenVGA, and there is a software workaround. The size of burst transfers can be
limited, which seems to solve the problem. Fixing this bug is future work.


\section{Future Work}
Open-source hardware is an area which is still in an early state of development.
There is no free and open implementation of a VGA-compatible graphics adapter. An
obvious direction for OpenVGA to take is enough VGA support to allow it to
function as a PC's primary graphics adapter. OpenVGA was designed as a step
towards VGA functionality and features a processor suitable for this task.

Another avenue of future work discussed here is software drivers so that OpenVGA
can be used with the Graphical User Interfaces (GUIs) of modern operating
systems, like GNU/Linux, Windows, and Mac OSX. Other areas for future work
include improvements to the hardware, like PCI Express support, using a more
modern FPGA, and greater memory bandwidth. These changes will require changes and
additions to the current set of logic cores as well.


\subsection{VGA Compatibility}
OpenVGA does not currently a VGA-compatible graphics adapter, this is due to the
lack of the firmware for VGA emulation. Chapter~\ref{BACKGROUND} covers the
components of a VGA which will have to be emulated. The quantity of firmware code
required is substantial and was beyond the scope of this project. A C compiler
would simplify this task, and could be another area of research.


\subsection{Software}
Due to PCI Plug and Play support, OpenVGA is detected and initialised correctly
by the host system, but it is not currently taken advantage of by any operating
systems since only a simple Linux kernel module has been written, and just for
testing purposes. A driver for X11 or Microsoft Windows would allow OpenVGA to be
a supported display device for these operating systems. Writing an X11 driver
should be straight-forward, since the OpenGraphics project has an open-source
driver available.

If OpenVGA is used for other uses, such as hardware computation, it will most
likely require additional custom software and drivers, though the current kernel
module may be enough for some applications, since it allows OpenVGA to be written
to, and read from, like a file.

TTA processors that have multiple data-transports are very time consuming to
program in assembly code. TTA16 would be a far more useful processor if there
was a C compiler for it. There are open-source C compilers for other TTA
processors~\cite{jaaskelainen2007cta, corporaal1993maa}, these are GCC ports,
and maybe one of these could be modified for TTA16 . Generating optimised
code for TTA processors is very difficult though.


\subsection{Hardware Improvements}
% TODO: DVI testing.
OpenVGA hardware works well and is low-cost but future modifications could
significantly improve performance and features. By changing to a four-layer PCB,
adding a PCI-Express PHY, an on-board clock-generator IC, a larger FPGA with more
I/O pins, and larger, wider, and faster memory IC would allow OpenVGA to support
high-resolution video modes, and allow it to be more useful for hardware
computation tasks. A current area of research, for example, is real-time
ray-tracing\cite{wald2004rrt, TTA_Ray_Trace}.

Xilinx have recently introduced a new low-cost FPGA product line, the Spartan-6
family, replacing Spartan-3 generation FPGAs. These are faster and have more
logic resources than their previous generation devices. FPGAs from other vendors
should be evaluated as well, like the Cyclone III from Altera, or a Lattice
ECP3\footnote{A disadvantage with Altera and Lattice is that these vendors do not
have a free tool-chain that supports the GNU/Linux operating system, only
currently Microsoft Windows.}. Another benefit of these newer FPGAs is they have
hardware support for DDR2 and DDR3 memory, addressing a current OpenVGA weakness.


\subsection{Logic Core Improvements}
There are two options for improving the current logic cores. The first approach
would be changes that expand the functionality of OpenVGA, and the second class
of improvements would optimise the current set of logic cores.

\subsubsection{New Features}
To complete VGA-compatibility, the PCI-to-Wishbone bridge would need modifying
so that it identifies itself as a VGA device. This is straight-forward, and is
covered here~\cite{PCI_Spec}.

It is also common for graphics adapters to contain logic for hardware
acceleration of 2D and 3D tasks. Some support for this could be done through
firmware with the existing processors, new functional units could be added to
these processors\footnote{Automatic synthesis of TTA processors is a possibility
too~\cite{hoogerbrugge1995ast}, this would allow processors to be developed
quickly for specific uses.}, or new logic cores could be added that provide this
functionality.


\subsubsection{Optimisations}
While individual logic cores have been heavily optimised for speed and size, they
could be modified to make more efficient use of the buses which connect them
together. For example, the PCI-to-Wishbone bridge does not use the burst-transfer
functionality of the Wishbone interconnect standard, nor does it support PCI
burst read transfers. This is because the logic required to support this is quite
complex. These changes will lower bus congestion, thereby increasing system
performance.

Another area that can be optimised is the cache. Currently, when the processor
performs a memory write it stalls until the completion of the transaction, which
can be many cycles. A write-back cache design reduces the frequency of this
problem. Also, when a memory read is issued by the processor, and if there is a
cache miss, the processor stalls until the entire cache-line has been fetched. It
would be possible to implement a system where the desired word is fetched first,
and then allowing the processor to continue operation.

A change to the SDRAM controller, adding write-data FIFOs, would allow multiple
memory writes to be queued, and completed at a time suitable to the memory
controller. This modification would probably add 60 logic slices to the size of
the controller though.


\section{Conclusion}
The design and construction of a low-cost, open-source graphics adapter has been
presented in this thesis. Open-source hardware is a relatively new area of
research. As long as the capabilities and price of programmable logic keeps
improving, open-source hardware will likely be an expanding domain too. This
project contributes OpenVGA to this area. Both as a stand-alone project, and as a
collection of free and open logic cores.
