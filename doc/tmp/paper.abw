<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE abiword PUBLIC "-//ABISOURCE//DTD AWML 1.0 Strict//EN" "http://www.abisource.com/awml.dtd">
<abiword template="false" styles="unlocked" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:math="http://www.w3.org/1998/Math/MathML" xid-max="164" xmlns:dc="http://purl.org/dc/elements/1.1/" fileformat="1.1" xmlns:svg="http://www.w3.org/2000/svg" xmlns:awml="http://www.abisource.com/awml.dtd" xmlns="http://www.abisource.com/awml.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.9.1" xml:space="preserve" props="dom-dir:ltr; document-footnote-restart-section:0; document-endnote-type:numeric; document-endnote-place-enddoc:1; document-endnote-initial:1; lang:en-NZ; document-endnote-restart-section:0; document-footnote-restart-page:0; document-footnote-type:numeric; document-footnote-initial:1; document-endnote-place-endsection:0">
<!-- ======================================================================== -->
<!-- This file is an AbiWord document.                                        -->
<!-- AbiWord is a free, Open Source word processor.                           -->
<!-- More information about AbiWord is available at http://www.abisource.com/ -->
<!-- You should not edit this file by hand.                                   -->
<!-- ======================================================================== -->

<metadata>
<m key="dc.format">application/x-abiword</m>
<m key="abiword.generator">AbiWord</m>
</metadata>
<history version="29" edit-time="29739" last-saved="1250128707" uid="6fe5b5f0-86f2-11de-8488-d06d108f05b7">
<version id="16" started="1250049968" uid="f7c81bc4-8702-11de-8488-d06d108f05b7" auto="0" top-xid="18"/>
<version id="24" started="1250075490" uid="cc32209e-8735-11de-93e6-e853beb7bbdc" auto="0" top-xid="84"/>
<version id="29" started="1250127440" uid="caed70f4-87ac-11de-8488-d06d108f05b7" auto="0" top-xid="153"/>
</history>
<styles>
<s type="P" name="Heading 3" basedon="Normal" followedby="Normal" props="keep-with-next:1; margin-top:22pt; font-weight:bold; margin-bottom:3pt; font-family:Liberation Sans; font-size:12pt"/>
<s type="P" name="Normal" followedby="Current Settings" props="font-family:Times New Roman; margin-top:0pt; color:000000; margin-left:0pt; widows:2; font-style:normal; text-indent:0in; text-position:normal; margin-right:0pt; text-decoration:none; bgcolor:transparent; line-height:1.0; font-size:12pt; margin-bottom:0pt; font-variant:normal; font-weight:normal; text-align:left; font-stretch:normal"/>
<s type="P" name="Heading 4" basedon="Normal" followedby="Normal" props="keep-with-next:1; margin-top:22pt; font-weight:bold; margin-bottom:3pt; font-family:Liberation Sans; font-size:12pt"/>
<s type="C" name="Reference" props="font-size:10pt"/>
</styles>
<pagesize pagetype="A4" orientation="portrait" width="8.267717" height="11.692913" units="in" page-scale="1.000000"/>
<section xid="1" props="page-margin-footer:0.5000in; page-margin-header:0.5000in; page-margin-right:1.0000in; page-margin-left:1.0000in; page-margin-top:1.0000in; page-margin-bottom:1.0000in">
<p style="Heading 3" xid="2" props="dom-dir:ltr">Abstract</p>
<p style="Normal" xid="14" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="15" props="text-align:left; dom-dir:ltr"><c></c>This paper compares the performance of conventional radix-2 program counters with program counters based on Feedback Shift Registers (FSRs) a class of cyclic sequence generator. FSR counters have constant time scaling with bitwidth, N , wheras FPGA-based radix-2 counters typically have O(N ) time-complexity due to the carry-chain. Program counter performance is measured by synthesis of standalone counter circuits, as well as synthesis of three FPGA-based processor designs modified to incorporate FSR program counters. Hybrid counters, combining both an FSR and a radix-2 counter, are presented as a solution to the potential cache-coherency issues of FSR program counters. Results show that high-speed processor designs benefit more from FSR program counters, allowing both greater operating frequency and the use of fewer logic resources.</p>
<p style="Normal" xid="8" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Heading 3" xid="9" props="dom-dir:ltr"><c></c>Introduction</p>
<p style="Normal" xid="10" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="13" props="text-align:left; dom-dir:ltr">A Program Counter (PC) circuit [10] generates the address of the next instruction to be fetched for execution. The greatest contributor to total PC circuit latency in an FPGA-based processor can be due to the counter that is used to increment the current PC value. This is because conventional radix-2 counters implemented within FPGAs can have long carry chains. Pipelining can be used to obtain a higher operating frequency but also increases logic usage, and likely increases the branch penalty. Some non-radix-2 cyclic sequence generators, for example a maximum-cycle Feedback Shift Register (FSR) [5, 13, 6], to generate the next instruction address can lead to a reduction in total PC latency. This is because FSR counters can be designed where the maximum depth of combinatorial logic required is only one gate [7] therefore the PC latency is constant with bit-width N . We explore if this reduction in PC circuit complexity can affect maximum processor operating frequency for three FPGA processor designs. The sequence of instruction addresses generated by a PC circuit using a maximum-cycle FSR is pseudo-random. For a processor fetching instructions from a small embedded memory this presents no problem. For processors that feature an instruction cache an FSR PC will have poor cache-coherency behaviour. As a solution we present a hybrid-PC architecture. The hybrid PC is the concatenation of two smaller counters. The hybrid PC uses a small radix-2 counter to step through instructions within a cache line, and an FSR counter that cycles between cache lines. When implemented within FPGA processors, this hybrid approach has low latency and avoids cache-coherency problems.</p>
<p style="Normal" xid="19" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Heading 3" xid="20" props="dom-dir:ltr"><c></c>Program Counters</p>
<p style="Normal" xid="21" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="22" props="text-align:left; dom-dir:ltr">Stan and buddies list the properties of generic up/down-counters but not all of these prop<c props="font-size: 12 pt">er</c><c props="font-family:Times New Roman; font-size: 12 pt">ties are </c><c props="font-family:Times New Roman; color:000000; text-decoration:none; text-position:normal; font-size: 12 pt; bgcolor:e8f2fe; font-weight:normal; font-style:normal">required</c><c props="font-family:Times New Roman; font-size: 12 pt"> for P</c>C circuits. A program counter must be RESETable, increment once every clock cycle as long as an ENABLE line is asserted, and sometimes has its value changed by branch instructions (so it needs to be LOADable, and have IN lines). The value also needs to be readable every clock cycle (using the OUT lines) in order to access the memory address to fetch the next instruction. There is no need to support other common counter features [14], such as being reversible, or any terminal count operations. A black box diagram for a generic PC circuit is shown in Figure 1.</p>
<p style="Normal" xid="23" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Heading 4" xid="24" props="dom-dir:ltr">1.2. Radix-2 Counters</p>
<p style="Normal" xid="26" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="27" props="text-align:left; dom-dir:ltr"><c></c>Synchronous radix-2 counters are conventionally used for Program Counters, however there is a trade-off between speed and size because of carry propagation from low-order to higher-order bits [14].</p>
<p style="Normal" xid="34" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="35" props="text-align:left; dom-dir:ltr"><c></c>The simplest radix-2 counter is a ripple-carry counter based on an adder [14]. This is slow (O(N) combinatorial delay with increasing bit-width N) but cheap in logic (O(N )). Xilinx FPGAs use carry chains to provide the logic for this. This can be improved to O(log N ) combinatorial delay using a carry-lookahead design [9] at the expense of extra logic.</p>
<p style="Normal" xid="36" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="37" props="text-align:left; dom-dir:ltr"><c></c>An approach that allows increment in constant time is a redundant format [8] which allows what is called `carry-free' addition, but that has two issues. A redundant representation needs twice as many latches and therefore consumes more FPGA resources. Another problem is that a redundant-output is unsuitable for providing an address to access instructions. The output first needs to be converted to a non-redundant format during each clock cycle, which is going to require O(log N ) propagation delay and extra logic for an adder. Some work has been done using hybrid redundant number systems [11] to reduce the number of extra registers, but there is still a substantial propagation delay converting that to a usable format.</p>
<p style="Normal" xid="38" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="39" props="text-align:left; dom-dir:ltr"><c></c>Another approach to designing an O(1) delay counter is to use a cascade [9] that begins with a short and fast counter, and continues with longer counters that only need to be incremented occasionally and don't need to be as fast. However, this requires the slower counters to have their increments to be precomputed [14] which makes the LOAD operation much more difficult.</p>
<p style="Normal" xid="28" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Heading 4" xid="29" props="dom-dir:ltr"><c></c>1.3. Cyclic Sequence Generators</p>
<p style="Normal" xid="30" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="31" props="text-align:left; dom-dir:ltr"><c></c>A cyclic sequence generator is a synchronous circuit that iterates through a cyclic sequence of states. For a program counter, it is desirable to have a simple circuit and a cyclic sequence that includes most of the possible states. A good candidate for this is a maximum cycle feedback shift register.</p>
<p style="Normal" xid="40" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="41" props="text-align:left; dom-dir:ltr"><c></c>A Feedback Shift Register (FSR) is a shift register that satisfies the condition that the current state is generated by a linear function of its previous state. There are many types of these, but the ones considered here are linear (use XOR gates), and have a constant maximum combinatorial path, therefore constant time performance (O(1)) with increasing bit width N (see Figure 2 for some examples of these). This compares favourably with radix-2 counters as described in Section 1.2. A well-known example of an FSR is a Linear-Feedback, Shift Register [5, 6] (LFSR) that are widely used in cryptography [6], communications systems, and for built-in self-test systems. A few of the types of FSR are:</p>
<p style="Normal" xid="42" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="43" props="text-align:left; dom-dir:ltr"><c></c>Fibonacci LFSR takes the output of several of the registers and XORs them together to feed to the input of the first register as shown in Figure 2a.</p>
<p style="Normal" xid="25" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="32" props="text-align:left; dom-dir:ltr">Galois LFSR takes the output of the last register and XORs it with several of the register inputs as shown in Figure 2b.</p>
<p style="Normal" xid="45" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="46" props="text-align:left; dom-dir:ltr"><c></c>Ring Generators [7] rearrange the shift register into a ring, and arranges the feedback connections so that they only involve a small amount of routing, as shown in Figure 2c. </p>
<p style="Normal" xid="47" props="text-align:left; dom-dir:ltr"><c></c>MFSR [18] (Multiple Feedback Shift Register) are a generalisation of ring generators, allowing any output to be XORed with any input, but limits the fan-in and fan-out to 2, as shown in Figure 2d.</p>
<p style="Normal" xid="48" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="49" props="text-align:left; dom-dir:ltr"><c></c>Also worth considering are cellular automata [3]. These are not Feedback Shift Registers but have similar properties. A c<c props="font-family:Times New Roman; font-size:12pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal; lang:en-NZ">ellular automaton</c> has each bit set from the XOR of the previous value of that bit and neighbouring bits, which require more XOR gates than FSRs but keep the routing very local.</p>
<p style="Normal" xid="50" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="51" props="text-align:left; dom-dir:ltr"><c></c>An N-stage linear FSR is maximum-cycle when all 2^N-1 non-zero states occur as the FSR is iterated. Note that a cycle of 2N cannot be achieved as the all-zero state will always map to the all-zero state. Any linear FSR can be represented as an N � N matrix M over the field GF (2), and this will be maximum cycle if and only of the characteristic polynomial p(x) = |M - xI| is primitive. Lists of primitive characteristic polynomials and counters with maximum cycles can easily be found [6, 2, 17] or generated.</p>
<p style="Normal" xid="52" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="53" props="text-align:left; dom-dir:ltr"><c></c>All these structures are very fast, as described above, and have a relatively small amount of logic (O(N ) which will mostly be the registers to store the bits), and a pseudo-random sequence. They will have similar performance, due to all having a maximum combinatorial part of just one XOR gate (In Fibonacci this may be 4 gates, but this is still only one LUT on an FPGA). Slight variations in performance may depend on required LUTs and routing in any particular FPGA technology choice and application. The worst case number of XOR gates, fan in and fan out is shown in Table 1. As the sequence is pseudo-random, the bits may also reordered to search for small routing improvements.</p>
<p style="Normal" xid="54" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="55" props="text-align:left; dom-dir:ltr"><c></c>FSR counters meet the counter requirements for PC circuit described in Section 1.1. They are easily loadable, support an enable, and the register can be read directly. One disadvantage to using FSRs is that the maximal cycle size is 2n - 1, instead of the 2n cycle of radix-2 counters. We refer to the address not generated in the 2n -1 cycle as the "zero address". While the zero address does not represent a significant fraction of the address space, this can be addressed with extra logic as used by Wang and McCluskey [16], but this brings the propagation delay back to O(log N ).</p>
<p style="Normal" xid="62" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="63" props="text-align:left; dom-dir:ltr"><c></c>For the rest of this work we use MFSR counters. They have good fan-in, fan-out, and a low gate count. Other FSRs could be used and would have very similar results (see Figure 2).</p>
<p style="Normal" xid="56" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Heading 4" xid="57" props="dom-dir:ltr"><c></c>Hybrid PCs</p>
<p style="Heading 4" xid="58" props="dom-dir:ltr"><c></c></p>
<p style="Normal" xid="59" props="text-align:left; dom-dir:ltr"><c></c>The instruction fetch-order of FSR PCs may lead to poor run-time performance for processor designs that contain an instruction cache. It is desirable to have a PC that increments through all of the instructions within a cache line before fetching a new cache line. For a cache line-size of 32 bytes, and a fixed instruction-width of 32 bits, there will be eight instructions within a cache line. Ideally, and in the absence of branching instructions, each of these eight instructions should be fetched from the cache before fetching another cache line from system memory.</p>
<p style="Normal" xid="60" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="61" props="text-align:left; dom-dir:ltr"><c></c>The solution presented here is to combine two counters into one PC, a radix-2 counter for the three least-significant bits and a MFSR for the most-significant bits. Since the Spartan-3 contains four-input Look-Up Tables (LUTs), and the Virtex-5 has six input LUTs, a 3-bit radix-2 counter can be built with just one layer of logic. When the upper count value is reached, the MFSR portion of the PC is then incremented.</p>
<p style="Heading 4" xid="65" props="dom-dir:ltr"><c></c>FPGA Synthesis of Simple Counter Circuits</p>
<p style="Normal" xid="68" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="69" props="text-align:left; dom-dir:ltr"><c></c>Performance of the synthesised radix-2 and FSR counters are shown in Figure 3. As the bit-width (N) increases radix-2 counters show a linear increase in latency, this is O(N ) time-complexity. The results show that for radix2 counters of more than 6 bits, latency can be estimated as 2.9 + 0.064 � N ns. The FSR counters have O(1) time complexity and a smaller constant of only 1.8 ns, compared with the radix-2 counters.</p>
<p style="Normal" xid="33" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="70" props="text-align:left; dom-dir:ltr">Figure 3: Counter circuit performance vs. counter size when synthesised for a Spartan-3 FPGA. The radix-2 counter was Verilog addition operator synthesised implementation used was the default that is generated by the Xilinx ISE 9.2 tools. This implementation used the hardware carry-chain that present in Spartan-3 devices.</p>
<p style="Normal" xid="71" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="72" props="text-align:left; dom-dir:ltr">3. FPGA Synthesis of Complete PC Circuits</p>
<p style="Normal" xid="81" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="82" props="text-align:left; dom-dir:ltr"><c></c>A simple PC circuit was used when investigating the effect of counter-type on PC performance. Figure 4 is a block diagram of the circuit used for testing and the counter used was one of FSR, radix-2, or a hybrid where the lowest 3 bits are radix-2. Bit widths ranging from 8 to 32 bits were used.</p>
<p style="Normal" xid="73" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="74" props="text-align:left; dom-dir:ltr">Figure 4: Block diagram of the PC circuit used for the counter comparison tests. The counter type was either a FSR, radix-2, or a <c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-NZ">FSR-radix-2 hybrid</c><c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-NZ"></c>.</p>
<p style="Normal" xid="75" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="76" props="text-align:left; dom-dir:ltr">3.1. PC Circuit Results</p>
<p style="Normal" xid="83" props="text-align:left; dom-dir:ltr"><c></c></p>
<p style="Normal" xid="84" props="text-align:left; dom-dir:ltr"><c></c>The results of the PC circuit synthesis are shown in Figure 5. As with the previous counter tests, the radix2 circuits scale linearly with increasing bit-width. Again though, the latencies of FSR-based circuits are lower than radix-2 and both the FSR and hybrid PCs have O(1) scaling with increasing bit-width. Due to the Xilinx synthesiser using the carry-chain logic for the radix-2 counters, and FSRs having a gate depth of just one, this is as expected. To demonstrate that the behaviour observed when synthesising for a Spartan-3 FPGA is not unique, Figure 6 also shows synthesis results for a Xilinx Virtex-5 FPGA. <c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">The</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">latency</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">scaling</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">with</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">increasing</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">bit-width</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">is</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">similar but</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">the</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">Virtex-</c><c props="font-family:Times New Roman; font-size:12 pt; color:ff6400; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">5</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> FPGAs are </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">clearly</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">faster</c><c props="font-family:Times New Roman; font-size:12 pt; color:1a1a1a; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"> </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">architectures.</c></p>
<p style="Normal" xid="99" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="100" props="dom-dir:ltr">Processor Design Examples</p>
<p style="Normal" xid="101" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="102" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">Three FPGA processors were synthesised and evaluated to show the effects of different PC circuits on maximum clock frequency. The three processor logic cores used are aeMB, TTA16, and RISC16. aeMB was designed to use a conventional radix-2 PC whereas RISC16 and TTA16 were designed to use a PC circuit based on either a FSR or radix-2 counter. This is to examine if substituting a FSR-based PC into an existing processor design leads to any performance gains of the processor as a whole, and if there is a detrimental effect of adding a radix-2-based PC to a processor designed for a FSR-based PC. A Xilinx Spartan-3 FPGA was again the synthesis target and Xilinx ISE 9.2 was the synthesis tool.</c></p>
<p style="Normal" xid="103" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="104" props="dom-dir:ltr"><c></c>aeMB: A MicroBlaze Compatible RISC Processor</p>
<p style="Normal" xid="105" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="106" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">The aeMB processor logic core is 32-bit, Harvard architecture, RISC processor with a three-stage pipeline. It is an open source project that was designed to be instruction compatible with the MicroBlaze core [19]. When the aeMB processor core was synthesised for a Spartan-3 FPGA it used about 2600 logic elements.</c></p>
<p style="Normal" xid="132" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="133" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">The critical path of aeMB, as determined from the Xilinx place-and-route timing report, is the instruction-cache look-up path. Total routing resources used were 515643 paths with the original radix-2 PC. The source code was modiﬁed, substituting a FSR PC for the radix-2 PC, and resynthesised. This was a straight PC-logic substitution and did not address any potential problems with relative branching and cache coherency.</c></p>
<p style="Normal" xid="134" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="135" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">Maximum operating frequency increased slightly, as is shown in Table 2, logic resource utilisation was similar, but the FSR design used only 503608 paths. This is a large change in pathing resources used for a small change to the total design. This large diﬀerence in pathing resources, caused </c><c props="font-family:Times New Roman; text-decoration:none; color:000000; font-size:12pt; text-position:normal; font-weight:normal; font-style:normal; lang:en-NZ">only </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">by the change to the PC circuit, was not observed with the other processor cores.</c></p>
<p style="Heading 4" xid="108" props="dom-dir:ltr">TTA16</p>
<p style="Normal" xid="124" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="125" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">TTA16 is a 16-bit, Transport Triggered Architecture [4] (TTA) processor optimised for Xilinx Spartan-3 FPGAs. It is an open-source, Harvard architecture processor and was designed for the high-throughput, data-processing tasks of the Open Video Graphics Adapter (OpenVGA) project. TTA processors have very simple instruction word formats and require only very simple instruction decoders resulting in smaller processor cores. The TTA16 PC circuit is similar to that shown in Figure 4 and contains source code for both types of PC, FSR or radix-2, and can be synthesised with either one.</c></p>
<p style="Normal" xid="130" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="131" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">TTA16 was the processor that showed the greatest frequency improvement with an FSR PC (see Table 2), the FSR-based counter has 22% greater clock frequency than with the radix-2 counter. TTA16 conﬁgured to use the FSR PC is substantially faster than with the radix-2 PC because TTA16 was designed to use a low-latency PC circuit. When TTA16 is synthesised with a radix-2 counter the PC circuit becomes the critical path limiting maximum frequency. We speculate that adding an additional pipeline stage to the radix-2 PC circuit may improve maximum processor frequency, but this would also increase branch latency and FPGA resources required.</c></p>
<p style="Normal" xid="126" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="127" props="dom-dir:ltr"><c></c>RISC16: A Small 16-bit RISC Processor</p>
<p style="Normal" xid="128" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="129" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">RISC16 was also designed for OpenVGA [15], for comparison with TTA16, and shares many design elements. The RISC16 core is has ﬁve pipeline stages arranged so that each has similar latency. Decreasing the latency of one small component, the PC circuit, would not be expected to have a big effect on overall performance. Table 2 shows that there were no substantial difference between the FSR and radix-2 PC implementations of the RISC16 processor core.</c></p>
<p style="Heading 4" xid="136" props="dom-dir:ltr"><c></c>Discussion</p>
<p style="Normal" xid="138" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="139" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">Radix-2 counters are the conventional counters used for the processors PC. These have been studied and used extensively. Memories, including caches, often support linear, burst transfers assuming a radix-2 count order. Current software tools, like assemblers and compilers, assume a radix-2 count order as well. FPGAs, like the Xilinx Spartan-3 and Virtex-5 families, contain carry-chains to support radix-2 counters as well.</c></p>
<p style="Normal" xid="140" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="141" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">Traditional assemblers will generate object code suitable only for the radix-2 PC increment sequence. For processors with FSR-based PCs, an assembler is needed that will use a description of the FSR to correctly re-order the processor instruction. An assembler was developed for this purpose and reads an XML-encoded complete processor description prior to generating the assembly output. The assembler supports FSR and radix-2, as well as hybrid PCs consisting of a concatenation of an arbitrary number of FSR and radix2 counters. For each FSR counter used the tap sequence describing the FSR is also encoded within the processor description ﬁle.</c></p>
<p style="Normal" xid="154" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="155" props="dom-dir:ltr"><c></c>FSR Program Counters</p>
<p style="Normal" xid="156" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="157" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">The FSR counters are very fast (see Figure 4) leading to a substantially lower-latency PC circuit (see Figure 3). This in turn leads to notable gains in maximum processor operating frequency for the processor with the highest operating frequency, TTA16 (see Table 2). Because a maximal-cycle FSR count cycle is different from a radix-2 counter this has effects on tools, instruction encoding, and cache coherency.</c></p>
<p style="Normal" xid="142" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="143" props="dom-dir:ltr"><c></c>Relative Instruction Addressing</p>
<p style="Normal" xid="144" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="145" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal; lang:en-NZ">The instruction set of many processors contain branch instructions that store an offset that is added to the current value of the PC.  These instructions are called </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">PC-relative branch instructions. When the offset is encoded with a bit-width narrower than the PC, this branching is difficult to do with FSRs.</c></p>
<p style="Normal" xid="163" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="164" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">PC-relative branching with small offsets is widely used in contemporary processors~\cite{} as it allows a subset of addresses, those that are close to the current instruction, to be encoded within an instruction. The simplest approach with FSR-based PCs is to not support PC relative branching. This problem is more easily resolved using </c><c props="font-family:Times New Roman; font-size:12pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal; lang:en-NZ">Hybrid PCs (see Section~\ref{}).</c></p>
<p style="Normal" xid="146" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="147" props="dom-dir:ltr"><c></c>Cache Coherency</p>
<p style="Normal" xid="148" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="149" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">For processor designs featuring an instruction cache, a FSR-based PC will lead to poor performance. A single FSR-based PC circuit will traverse program memory in a pseudo-random count cycle. Caches are typically designed to fetch multiple words from sequential adresses, called cache lines. A FSR PC circuit may only execute one instruction from this cache line, and then the cache may need to fetch another. A solution to this problem is introduced in Section 1.4 and then issues are discussed in Section 5.2.</c></p>
<p style="Normal" xid="150" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="151" props="dom-dir:ltr"><c></c>Hybrid Program Counters</p>
<p style="Normal" xid="152" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="153" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">The synthesis results, shown in Figures 5 and 6, for the hybrid PCs described in Section 1.4 show that performance is greater than radix-2 PCs at all tested bit-widths. They are therefore a good solution to the cache coherency problems of FSRs. Figures 5 and 6 show that hybrid PCs have only slightly higher latency than pure FSR PCs and with the same constant-latency behaviour with increasing N . Hybrid PCs can also be used to solve problems with relative branching and position independent code, though this is future work. With a hybrid-PC, the FSR portion will not increment when its value is zero, so there is one entire cache line which will not be accessed by the count cycle. This need not be a disadvantage because the ﬁrst cache line could be used to store other information, for example the interrupt vector table. 6. Conclusions We have designed PC circuits that can allow some FPGA-based processors to operate at higher frequencies. This is because FSR-based counters have very low latency, a depth of just one logic gate, and PC circuits utilising</c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="113" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="114" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"><pbr/>FSRs can have substantially lower latency when implemented in FPGAs. Due to the constant-time behaviour, with increasing bit-width N , FSR counters have an even greater advantage, relative to radix-2 counters, when N is large. For small embedded FPGA processors executing instructions stored in local SRAMs, the pseudo-random count cycle of FSRs is no signiﬁcant problem either as long as the user has the necessary tools to generate code. We have also presented hybrid PCs to solve the FSR cache-coherency issues for processors that use an instruction cache to reduce average latency for instruction fetching. </c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="116" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Heading 4" xid="117" props="dom-dir:ltr"><c></c>6.1. Future Work</p>
<p style="Normal" xid="118" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="119" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">There can be many possible maximal-cycle FSRs for a particular bit-width. Some FSRs, due to each having a slightly diﬀerent circuit, may be faster for a particular implementation than other FSRs. Testing was not performed to ﬁnd the fastest available FSR circuit for a particular implementation. A future project might be searching amongst the many possible FSRs to ﬁnd the lowest latency circuit.</c></p>
<p style="Normal" xid="120" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="121" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">Modern compilers can generate position independent code making use of relative branching that is not practicable with a pure FSR-based PC. Further work exploring hybrid program counters, consisting of three or more smaller counters, could probably be used to solve the FSR relative addressing problems.</c></p>
<p style="Normal" xid="122" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
<p style="Normal" xid="123" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal">The emphasis of this work is on FPGA-based processors. Due to their very low gate depth and reduced logic complexity FSR and FSR-radix-2 hybrid PCs may also prove useful with some very low gate-count, or very high clock frequency processors realised in Silicon.</c></p>
<p style="Normal" xid="115" props="text-align:left; dom-dir:ltr"><c props="font-family:Times New Roman; font-size:12 pt; color:000000; text-decoration:none; text-position:normal; font-weight:normal; font-style:normal"></c></p>
</section>
</abiword>
